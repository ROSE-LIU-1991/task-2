<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>葡萄藤PPT</title>

	<link rel="stylesheet" href="./css/reveal/reveal.css">

	<!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
	<link rel="stylesheet" href="./css/reveal/theme/ptt.css">

	<!-- syntax highlighting 代码高亮主题 -->
	<link rel="stylesheet" href="./lib/reveal/css/zenburn.css">

	<link rel="stylesheet" href="./task-js-1.css">

	<!-- 打印和PDF输出样式 -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? './css/reveal/print/pdf.css' :
			'../css/reveal/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<img src="./img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
	<map name="pttmap">
		<area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank" />
	</map>
	<div class="reveal">
		<div class="slides">
			<section class="txt">
				<h1></h1>
				<h2>小课堂【js-01】</h2>
				<h4>课题：JS有哪些数据类型？</h4>
				<p>分享人：吴胜</p>
			</section>

			<section>
				<p>目录</p>
				<p>1.背景介绍</p>
				<p>2.知识剖析</p>
				<p>3.常见问题</p>
				<p>4.解决方案</p>
				<p>5.编码实战</p>
				<p>6.扩展思考</p>
				<p>7.参考文献</p>
				<p>8.更多讨论</p>
			</section>

			<section>
				<section>
					<h3>
						1.背景介绍
					</h3>
				</section>
				<section>
					<h3 class="txt-word-2">
						js中有两种数据类型<br><br>
					</h3>
					<h5 class="txt-word-3">
						&emsp;&emsp;简单数据类型（也称基本数据类型）：Undefined;Null;Boolean;Number和String。<br><br>
						&emsp;&emsp;引用数据类型（也称复杂数据类型），其中包括Object；Array；Function等等。<br><br>
						&emsp;&emsp;PS:在引用数据类型中，又有三个特殊的引用类型，和基本数据类型相似。
					</h5>
				</section>
			</section>

			<section>
				<section>
					<h3>2.知识剖析</h3>
				</section>
				<section>
					<img src="./img/demo/1.png">
				</section>
				<section>
					<h3>辨别数据</h3>
					<h5 class="txt-word-3">我们可以用typeof()来辨别个别数据的结果</h5>
					<p class="txt-word-3"> typeof （ 123 ）　　 //Number<br>
						typeof （ 'abc' ）　　//String<br>
						typeof （ true ） //Boolean<br>
						typeof （ undefined ） //Undefined<br>
						typeof （ null ） //Object<br>
						typeof （ { } ） //Object<br>
						typeof （ [ ] ） //Object<br>
						typeof （ function (){} ） //Function
					</p>
					<h4 class="txt-word-3">经过辨别后，对比上面结果，就会发现null、{}、[]都返回的是Object，所以由此得知，typeof()对null，object，array是无法识别的。</h4>
				</section>
				<section>
					<h3>基本数据和引用数据的特点和区别</h3>
					<h4 class="txt-word-3">基本数据类型</h4>
					<p class="txt-word-3"> 基本数据类型的值是不可变的<br>
						任何方法都无法改变一个基本类型的值，比如一个字符串：<br>
						var s = "hello";<br>
						s.toUpperCase()//HELLO;<br>
						console.log(s)//hello<br>
					</p>
					<h4 class="txt-word-3">这里调用toUpperCase()方法后返回的是
						<!-- 
						-->一个新的字符串，跟原先定义的变量s并没有关系</h4>
				</section>
				<section>
					<h4>基本数据类型不可以添加属性和方法</h4>
					<p class="txt-word-3">
						var p = "change";<br>
						p.age = 29;<br>
						p.method = function(){console.log(name)};<br>
						console.log(p.age)//undefined<br>
						console.log(p.method)//undefined<br>
					</p>
					<h4 class="txt-word-3">通过上面的代码，我们知道不能给基本类型添加属性和方法
						,也再次说明基本类型是不可变的</h4>
				</section>
				<section>
					<h4>基本数据类型的赋值是简单赋值</h4>
					<p class="txt-word-3">
						如果从一个变量向另一个变量赋值基本类型的值，会在变量对象上创建一个新值，
						然后把该值复制到为新变量分配的位置上<br>
						var a = 10;<br>
						var b = a;<br>
						a++;<br>
						console.log(a)//11<br>
						console.log(b)//10<br>
					</p>
					<h4 class="txt-word-3">上面的代码中，a中保存的值是10.当使用a的值来初始化b时，
						b中也保存了值10.但b中的10和a中的10是完全独立的.b中的值只是a中值的一个副本.
						所以这两个变量可以参与任何操作而不会相互影响</h4>
				</section>
				<section>
					<h4>基本数据类型的比较是值的比较</h4>
					<p class="txt-word-3">
						var person1 = '{}';<br>
						var person2 = '{}';<br>
						console.log(person1 == person2); // true
					</p>
				</section>
				<section>
					<h4 class="txt-word-3">引用数据类型</h4>
					<h5 class="txt-word-3">引用类型的值是可以改变的</h5>
					<p class="txt-word-3">
						var a = [1,2,3];<br>
						a[0] = 0;//更改数组的一个元素<br>
						a[3] = 4;//给数组增加一个元素<br>
					</p>
				</section>
				<section>
					<h4 class="txt-word-3">引用类型可以添加属性和方法</h4>
					<p class="txt-word-3">var person = {};<br>
						person.name = "change";<br>
						person.say = function(){alert("hello");}<br>
						console.log(person.name)//change<br>
						console.log(person.say)//function(){alert("hello");}<br>
					</p>
				</section>
				<section>
					<h4 class="txt-word-3">引用类型的赋值是对象引用</h4>
					<p class="txt-word-3">
						var a = {};<br>
						var b= a;<br>
						a.name = "change";<br>
						console.log(a.name)//change;<br>
						console.log(b.name)//change<br>
						b.age = 29;<br>
						console.log(a.age)//29<br>
						console.log(b.age)//29<br>
					</p>
				</section>
				<section>
					<h4 class="txt-word-3">当从一个变量向另一个变量赋值引用类型的值时，
						<!-- 
					-->同样也会将储存在变量中的对象的值复制一份放到为新变量分配的空间中.
						<!-- 
						 -->引用类型保存在变量中的是对象在堆内存中的地址，所以，与基本数
						<!-- 
						 -->据类型的简单赋值不同，这个值的副本实际上是一个指针，而这个指
						<!-- 
						 -->针指向存储在堆内存的一个对象.那么赋值操作后，两个变量都保存了
						<!-- 
						 -->同一个对象地址，而这两个地址指向了同一个对象.因此，改变其中任何一个变量，都会互相影响
					</h4>
				</section>
				<section>
					<h4 class="txt-word-3">引用类型的比较是引用的比较</h4>
					<p class="txt-word-3">
						var person1 = {};<br>
						var person2 = {};<br>
						console.log(person1 == person2)//false<br>
					</p>
					<h4 class="txt-word-3">
						引用类型的比较是引用的比较，换句话说，就是比较两个对象保存
						<!-- 
						-->在栈区的指向堆内存的地址是否相同，此时，虽然p1和p2看起来
						<!-- 
						 -->都是一个"{}"，但是他们保存在栈区中的指向堆内存的地址却是
						<!-- 
						 -->不同的，所以两个对象不相等</h4>
				</section>
			</section>
			<section>
				<section>
					<h3>3.常见问题</h3>
				</section>
				<section>
					<h3 class="txt">jAVAScirpt数据能否转换？</h3>
				</section>
			</section>
			<section>
				<section>
					<h3>4.解决方案</h3>
					<h4 class="txt-word-3">js中的不同类型数据在运算过程中会自动进行转换。<br>
						运算规则为：<br>
						Number+String=String<br>
						Number+Boolean=Number<br>
						String+Boolean=String<br>
						Boolean+Boolean=Number<br>
				</section>
				<section>
					<h4 class="txt-word-3">
						var str1 = "a";<br>
						var num1 = "1";<br>
						var bool1 = "true";<br>
						var bool2 = "false";<br>
						console.log(str1 + num1);<br>
						console.log(str1 + bool1);<br>
						console.log(num1 + bool1);<br>
						console.log(bool1 + bool2);<br>
					</h4>
				</section>
				<section>
					<h4 class="txt-word-3">
						数组和其他类型的变量进行运算时都转化成string<br>
						var arr=[1，2,3];<br>
						var a= "789";<br>
						typeof(arr+a);<br>
					</h4>
				</section>
				<section>
					<h4 class="txt-word-3">
						布尔值和数组运算时<br>
						var arr=[1,2,3];<br>
						var a= "true";<br>
						console.log(arr+a);<br>
					</h4>
				</section>
				<section>
					<h4 class="txt-word-3">
						对象和数组运算时<br>
						var arr=[1,2,3];<br>
						var obj= {name:"my"num:;"0"}<br>
						console.log(arr+obj);<br>
					</h4>
				</section>
			</section>
			<section>
				<section>
					<h3>5.代码实战</h3>
				</section>
			</section>

			<section>
				<section>
					<h3>6.拓展思考</h3>
				</section>
				<section>
					<h4 class="txt-word-3">
						栈，堆是什么？
					</h4>
				</section>
				<section>

					<h4 class="txt-word-3">
						在ECMAScript中，变量可以存放两种类型的值，即原始值和引用值。<br>
						原始值指的就是代表原始数据类型（基本数据类型）的值，<br>
						引用值指的就是复合数据类型(引用数据类型)的值。
					</h4>
				</section>
				<section>
					<h4 class="txt-word-3">
						原始值与引用值对应存在两种结构的内存即栈和堆<br>
						栈是一种后进先出的数据结构，看下图<br>
						<img src="./img/demo/3.png"><br>
						原始值是存储在栈中的简单数据，也就是说，他们的值直接存储在变量访问的位置。
					</h4>
				</section>
				<section>
					<h4 class="txt-word-3">
						堆是基于散列算法的数据结构，在javascript中，引用值是存放在堆中的。<br>
						引用值是用来引用存储在堆中的对象<br>
						也就是说，存储在变量处的值(即指向对象的变量，存储在栈中）是一个指针，指向存储在堆中的实际对象.如下图<br>
						<img src="./img/demo/4.png">
					</h4>
				</section>
				<section>
					<h4 class="txt-word-3">
						var obj = new Object();<br>
						obj存储在栈中它指向于new Object()这个对象，<br>
						而new Object()是存放在堆中的。
					</h4>
				</section>
				<section>
					<h4 class="txt-word-3">
						那为什么引用值要放在堆中，而原始值要放在栈中.
					</h4>
				</section>
				<!-- <section>
					<h4 class="txt-word-3">
						我们先看一串代码<br>
						function Person(id,name,age){<br>
						this.id = id;<br>
						this.name = name;<br>
						this.age = age;<br>
						}<br>
						var num = 10;<br>
						var bol = true;<br>
						var str = "abc";<br>
						var obj = new Object();<br>
						var arr = ['a','b','c'];<br>
						var person = new Person(100,"jx1"",25);<br>
					</h4>
				</section>
				<section>
					<img src="./img/demo/2.png">
					<h4 class="txt-word-3">
						由上图可知，我们无法直接操纵堆中的数据，
						!-- 
						--也就是说我们无法直接操纵对象，但我们可以
						!-- 
						 --通过栈中对对象的引用来操作对象，就像我们通
						!-- 
						 --过遥控机操作电视机一样。
					</h4>
				</section> -->
				<section>
					<h4 class="txt-word-3">

						&emsp;&emsp;
						堆比栈大，栈比堆的运算速度快。<br>
						&emsp;&emsp;引用数据类型是一个复杂的结构，并且可以自由扩展，如：数组
						可以无限扩充，对象可以自由添加属性。将他们放在堆
						<!-- 
						 -->中是为了不影响栈的效率。而是通过引用的方式查找到
						<!-- 
						 -->堆中的实际对象再进行操作。<br>
						&emsp;&emsp;相对于引用数据类型而言，简单数据类型就比较稳定，
						<!-- 
						-->并且它只占据很小的内存。不将简单数据类型放在堆是
						<!-- 
						 -->因为通过引用到堆中查找实际对象是要花费时间的，而
						<!-- 
						 -->这个综合成本远大于直接从栈中取得实际值的成本。所
						<!-- 
						 -->以简单数据类型的值直接存放在栈中。
					</h4>
				</section>
			</section>
			<section>
				<h3>7.参考文献</h3>
				<h4><a class="txt-a" href="https://blog.csdn.net/liuguochao1024/article/details/79147418">js的数据类型</a></h4>
				<h4><a class="txt-a" href="https://www.cnblogs.com/chaoyuehedy/p/7894971.html">引用类型与原始类型的区别</a></h4>
				<h4><a class="txt-a" href="https://blog.csdn.net/weixin_42392456/article/details/81213864">js常见问题总结（1）——数据类型相关</a></h4>
				<h4><a class="txt-a" href="https://www.jb51.net/article/135920.htm">JavaScript基础心法 数据类型</a></h4>
			</section>
			<section>
				<h3>8.更多讨论</h3>
				<h4 class="txt-word-3">
					结合前面的只是来理解在js中的一句话：能量是守衡的，无非是时间换空间，空间换时间的问题。
				</h4>
			</section>

			<section>
				<h4>鸣谢</h4>
				<p>感谢大家观看</p>
				<p>
					<small>BY : 吴胜</small>
				</p>
			</section>
		</div>
	</div>

	<script src="./lib/reveal/js/head.min.js"></script>
	<script src="./lib/reveal/reveal.js"></script>

	<script>
		// 以下为常见配置属性的默认值
		// {
		// 	controls: true, // 是否在右下角展示控制条
		// 	progress: true, // 是否显示演示的进度条
		// 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
		// 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
		// 	keyboard: true, // 是否启用键盘快捷键来导航
		// 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
		// 	center: true, // 是否将幻灯片垂直居中
		// 	touch: true, // 是否在触屏设备上启用触摸滑动切换
		// 	loop: false, // 是否循环演示
		// 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
		// 	fragments: true, // 全局开启和关闭碎片。
		// 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
		// 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
		// 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
		// 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
		// }

		// 初始化幻灯片
		Reveal.initialize({
			history: true,
			dependencies: [{
					src: './plugin/markdown/marked.js'
				},
				{
					src: './plugin/markdown/markdown.js'
				},
				{
					src: './plugin/notes/notes.js',
					async: true
				},
				{
					src: './plugin/highlight/highlight.js',
					async: true,
					callback: function () {
						hljs.initHighlightingOnLoad();
					}
				}
			]
		});
	</script>
</body>

</html>